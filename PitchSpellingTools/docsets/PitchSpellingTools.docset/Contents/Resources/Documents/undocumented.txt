PitchSpelling+Resolution.swift
	public enum Resolution: Float
PitchSpelling+CustomStringConvertible.swift
	public var description: String
Spellability.swift
	public enum Spellability
IntervalQualityKind.swift
	case doubleDiminishedUnison = "dd1"
	case diminishedUnison = "d1"
	case perfectUnison = "P1"
	case augmentedUnison = "A1"
	case doubleAugmentedUnison = "AA1"
	case doubleDiminishedSecond = "dd2"
	case diminishedSecond = "d2"
	case minorSecond = "m2"
	case majorSecond = "M2"
	case augmentedSecond = "A2"
	case doubleAugmentedSecond = "AA2"
	case doubleDiminishedThird = "dd3"
	case diminishedThird = "d3"
	case minorThird	= "m3"
	case majorThird	= "M3"
	case augmentedThird = "A3"
	case doubleAugmentedThird = "AA3"
	case doubleDiminishedFourth = "dd4"
	case diminishedFourth = "d4"
	case perfectFourth = "P4"
	case augmentedFourth = "A4"
	case doubleAugmentedFourth = "AA4"
	case doubleDiminishedFifth = "dd5"
	case diminishedFifth = "d5"
	case perfectFifth = "P5"
	case augmentedFifth = "A5"
	case doubleAugmentedFifth = "AA5"
	case doubleDiminishedSixth = "dd6"
	case diminishedSixth = "d6"
	case minorSixth = "m6"
	case majorSixth = "M6"
	case augmentedSixth = "A6"
	case doubleAugmentedSixth = "AA6"
	case doubleDiminishedSeventh = "dd7"
	case diminishedSeventh = "d7"
	case minorSeventh = "m7"
	case majorSeventh = "M7"
	case augmentedSeventh = "A7"
	case doubleAugmentedSeventh = "AA7"
	public var hasValidIntervalQuality: Bool
Path.swift
	public struct Path
	public struct Path
	public struct Path
PitchClass+PitchSpelling.swift
	public var spellingPriority: Int?
SpelledPitchSet.swift
	public init(arrayLiteral elements: Element...)
	public func == (lhs: SpelledPitchSet, rhs: SpelledPitchSet) -> Bool
Tree.swift
	public final class Tree
PitchSpellingDyad.swift
	public var isLetterNameMatching: Bool
	public var isFineCompatibleLoose: Bool
	public func == (lhs: PitchSpellingDyad, rhs: PitchSpellingDyad) -> Bool
Node.swift
	public final class Node: NodeType
	public final class Node : NodeType
	public func == (lhs: Node, rhs: Node) -> Bool
	public final class Node : NodeType
PitchSpelling.swift
	public init(
        letterName: LetterName,
        coarse: CoarseAdjustment = .natural,
        fine: FineAdjustment = .none
    )
	public var hashValue: Int { return "\(letterName),\(coarse),\(fine)".hashValue }
	public func == (lhs: PitchSpelling, rhs: PitchSpelling) -> Bool
PitchSpellingRanking.swift
	public var rules: [(PitchSpellingDyad) -> Bool]
SpelledPitch.swift
	public var octave: Int
	public func == (lhs: SpelledPitch, rhs: SpelledPitch) -> Bool
SpelledDyad.swift
	public struct SpelledDyad
IntervalQuality.swift
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public static let doubleAugmented: EnumKind = .doubleAugmentedSecond
	public override class var members: [EnumKind] { return imperfectMembers }
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public class func kind(forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad)
        -> EnumKind
PitchSpelling+LetterName.swift
	public init?(string: String)
PitchSpellingDyad+CustomStringConvertible.swift
	public var description: String
