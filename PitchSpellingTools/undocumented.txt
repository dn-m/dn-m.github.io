PitchSetDyadSpeller.swift
	public struct PitchSetDyadSpeller: PitchSpeller
Dyad+PitchSpelling.swift
	public enum Error: ErrorType
	public var hasEighthTone: Bool
	public var hasQuarterTone: Bool
	public var finestResolution: Float
	public var canBeSpelledObjectively: Bool
	public var isFullyAmbiguouslySpellable: Bool
	public var isSemiAmbiguouslySpellable: Bool
	public var defaultSpellingDyad: PitchSpellingDyad?
	public var objectivelySpellableAndNot: (Pitch, Pitch)?
	public func spellWithDefaultSpellings() throws -> SpelledDyad
	public func spell(with spellingDyad: PitchSpellingDyad) throws -> SpelledDyad
PitchSpelling+Resolution.swift
	public enum Resolution: Float
PitchSpelling+CustomStringConvertible.swift
	public var description: String
IntervalQualityKind.swift
	case doubleDiminishedUnison = "dd1"
	case diminishedUnison = "d1"
	case perfectUnison = "P1"
	case augmentedUnison = "A1"
	case doubleAugmentedUnison = "AA1"
	case doubleDiminishedSecond = "dd2"
	case diminishedSecond = "d2"
	case minorSecond = "m2"
	case majorSecond = "M2"
	case augmentedSecond = "A2"
	case doubleAugmentedSecond = "AA2"
	case doubleDiminishedThird = "dd3"
	case diminishedThird = "d3"
	case minorThird	= "m3"
	case majorThird	= "M3"
	case augmentedThird = "A3"
	case doubleAugmentedThird = "AA3"
	case doubleDiminishedFourth = "dd4"
	case diminishedFourth = "d4"
	case perfectFourth = "P4"
	case augmentedFourth = "A4"
	case doubleAugmentedFourth = "AA4"
	case doubleDiminishedFifth = "dd5"
	case diminishedFifth = "d5"
	case perfectFifth = "P5"
	case augmentedFifth = "A5"
	case doubleAugmentedFifth = "AA5"
	case doubleDiminishedSixth = "dd6"
	case diminishedSixth = "d6"
	case minorSixth = "m6"
	case majorSixth = "M6"
	case augmentedSixth = "A6"
	case doubleAugmentedSixth = "AA6"
	case doubleDiminishedSeventh = "dd7"
	case diminishedSeventh = "d7"
	case minorSeventh = "m7"
	case majorSeventh = "M7"
	case augmentedSeventh = "A7"
	case doubleAugmentedSeventh = "AA7"
	public var hasValidIntervalQuality: Bool
PitchSpellingNode.swift
	public var rank: Float? = nil
	public let pitch: Pitch
	public func apply(rank: Float)
	public func penalize(by amount: Float)
	public func == (lhs: PitchSpellingNode, rhs: PitchSpellingNode) -> Bool
	public func < (lhs: PitchSpellingNode, rhs: PitchSpellingNode) -> Bool
	public var description: String
PitchClass+PitchSpelling.swift
	public var spellingPriority: Int?
SpelledPitchSet.swift
	public func == (lhs: SpelledPitchSet, rhs: SpelledPitchSet) -> Bool
PitchSet+PitchSpelling.swift
	public var sortedBySpellingUrgency: [Pitch]
	public func spelledWithDefaultSpellings() throws -> SpelledPitchSet
PitchSpellingLevel.swift
	public var highestRanked: PitchSpellingNode? { return nodes.sort { $0.rank > $1.rank }.first }
	public var description: String
PitchSpellingDyad.swift
	public var isCoarseCompatible: Bool { return eitherIsNatural || isCoarseMatching }
	public var isCoarseDirectionCompatible: Bool
	public var isCoarseResolutionMatching: Bool
	public var isCoarseResolutionCompatible: Bool
	public var eitherHasNoFineAdjustment: Bool
	public var eitherHasFineAdjustment: Bool
	public var hasValidIntervalQuality: Bool { return intervalQuality.hasValidIntervalQuality }
	public var meanCoarseDistance: Float
	public var hashValue: Int { return b.hashValue * a.hashValue }
	public func == (lhs: PitchSpellingDyad, rhs: PitchSpellingDyad) -> Bool
NodeResource.swift
	public struct NodeResource
	public struct NodeResource
PitchSpelling.swift
	case noSpellingForPitch(Pitch)
	public var hashValue: Int { return "\(letterName),\(coarse),\(fine)".hashValue }
	public func == (lhs: PitchSpelling, rhs: PitchSpelling) -> Bool
SemiAmbiguousPitchSpellingRanker.swift
	public lazy var edges: [PitchSpellingEdge] =
PitchSetSpeller.swift
	public func applyRankings()
PitchSpellingRanking.swift
	var edges: [PitchSpellingEdge] { get }
	var rules: [(PitchSpellingDyad) -> Bool] { get }
	func applyRankings(withAmount amount: Float)
	public var rules: [(PitchSpellingDyad) -> Bool]
SpelledPitch.swift
	public let pitch: Pitch
	public let spelling: PitchSpelling
	public init(_ pitch: Pitch, _ spelling: PitchSpelling)
	public var description: String
	public var hashValue: Int { return "\(pitch)\(spelling)".hashValue }
	public func == (lhs: SpelledPitch, rhs: SpelledPitch) -> Bool
SpelledDyad.swift
	public struct SpelledDyad
IntervalQuality.swift
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public static let doubleAugmented: EnumKind = .doubleAugmentedSecond
	public override class var members: [EnumKind] { return imperfectMembers }
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public override class func kind(
            forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad
        ) -> EnumKind
	public class func kind(forPitchSpellingDyad pitchSpellingDyad: PitchSpellingDyad)
        -> EnumKind
PitchSpelling+LetterName.swift
	public init?(string: String)
PitchSpellingEdge.swift
	public final class PitchSpellingEdge
	public func == (lhs: PitchSpellingEdge, rhs: PitchSpellingEdge) -> Bool
	public func < (lhs: PitchSpellingEdge, rhs: PitchSpellingEdge) -> Bool
	public final class PitchSpellingEdge
PitchSpeller.swift
	public protocol PitchSpeller
Pitch+PitchSpelling.swift
	public var spellingsWithoutUnconventionalEnharmonics: [PitchSpelling]
	public func spelledWithDefaultSpelling() throws -> SpelledPitch
PitchSpellingDyad+CustomStringConvertible.swift
	public var description: String
